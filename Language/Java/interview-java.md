# Java,JVM
## 1.java8 中hashmap  put一个数据 具体执行流程是什么样的
> 1. 因为HashMap在初始化的时候, 没有初始化table, 所以在第一次插入时需要初始化table，默认长度为16;
> 2. 通过与运算计算对应 hash 值的下标, 如果下标的位置没有元素, 则直接创建;
> 3. 如果有元素，说明有hash冲突，需要进行一下三种判断：
>> 1. 判断两个冲突的hash值是否相等。如果相等，则将已经存在的值赋给变量e。
>> 2. 如果key不相等，则判断是否是红黑树类型，如果是则交给红黑树追加此元素。
>> 3. 如果key不相等，而且不是红黑树类型，则是链表，那么就遍历链表中的每一个key和给定的key是否相等。如果链表的大小大于等于8则将列表改成红黑树。
> 4. 如果之前三个判断返回的e不为空，则更新key对应的value值并返回之前的旧值。
> 5. 迭代器的modCount+1.
> 6. 如果当前的数组长度已经大于阈值了。则进行扩容操作。


## 2.Java强弱软虚四种引用的作用和应用场景
> #### 强引用（Strong Reference）
> 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
> #### 软引用（Soft Reference）
> 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
>
> 下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。
>
> 设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了内存溢出的问题。
>
> 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
> #### 弱引用（Weak Reference）
> 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
>
> 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
> 
> **当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue。只有前面几步完成后，软引用和弱引用的get方法才会返回null。**
> #### 虚引用（Phantom Reference）
> “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
>
> 虚引用主要用于检测对象是否已经从内存中删除，跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
>
> 虚引用的唯一目的是当对象被回收时收到一个系统通知。
>
>
> **强引用:** JVM宁可抛出OOM，也不会让GC回收具有强引用得对象。
> **软引用:** 只有在内存空间不足时才会被回收。
> **弱引用:** 在GC时，一旦发现只具有有弱引用的对象，不管当前内存空间是否足够，都会被回收。
> **虚引用:** 任何时候都可能被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对线内存之前，把这个虚引用加入到与之相关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来做GC回收Object的标志。



## 3.[内存泄漏相关](https://zhuanlan.zhihu.com/p/25213586)
> ##### java中的内存分配
> 1. **静态储存区:** 又叫方法区，编译期就分配好，程序整个运行期间都存在，主要存放静态数据，全局变量和class文件。**「存放在数据主内存」**
> 2. **栈区:** 在方法执行时，会在栈区内存中创建方法内部的局部变量，方法结束后自动释放。**「栈区数据存放在主内存」**
> 3. **堆区:** 通常存放new出来得对象。由java垃圾回收器回收。**「存放在高速缓冲区」**
> 4. **执行引擎:** 将方法区中对应方法的arm指令集加载到栈区，cpu直接从高速缓冲区取arm指令，一条一条执行。执行引擎就像一个中介，方法对应的arm指令相当于交易的物品。
>
> #### 1.单例造成的内存泄漏
>> 单例的静态特性导致其声明周期和应用一样长
>> ##### 解决方法
>> 1. 将该属性改成弱引用
>> 2. 如果传入Context，传入ApplicationContext
> #### 2.InnerClass匿名内部类
>> 在java中，非静态内部类和匿名内部类都会潜在引用它们所属的外部类，但是，静态内部类却不会。如果这个非静态内部类实例做了一些耗时操作，就会造成外围对象不会被回收，从而导致内存泄漏。
>> ##### 解决方案
>> 1. 内部类变成静态内部类，如果有强引用Activity中的属性，则将该属性的引用方式改成弱引用。
>> 2. 在业务允许的情况下，当Activity执行onDestroy时，结束这些耗时任务。
> #### 3.Activity Context不正确使用
>> 当类或方法需要Context对象的时候常见的做法是使用Activity作为Context参数。这就意味着View对象对整个Activity保持引用。
>>
>> 假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转是都重新加载图片所用的时间较多。为了提高屏幕旋转是Activity的创建速度，最简单的方法时将这个Bitmap对象使用Static修饰。 当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了当旋转屏幕时，Activity无法被回收，而造成内存泄露。
>> ##### 解决方法
>> 1. 使用ApplicationContext代替ActivityContext。
>> 2. 对Context的引用不要超过它本身的生命周期，慎重的对Context使用static关键字。Context里如果有线程，一定要及时在onDestroy()中停止。
> #### 4.Handler引起的内存泄漏
>> 当Handler中有延迟的任务或者是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对外部类的引用，这条引用关系会一直保持到消息被处理，从而导致了Activity无法被垃圾回收器回收，而导致了内存泄漏。
>> ##### 解决方法
>> 1. 可以把Handler写在单独的类文件中，或者是使用静态内部类得形式实现。
>> 2. 如果想在Handler内部去调用所在的activity,那么可以在Handler的内部使用弱引用的方式指向所在的activity。使用static+WeakReference的方式来断开handler和activity之间的引用关系。
>>
> #### 5.注册监听器的泄漏
>> 系统服务可以通过Context.getSystemService获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果Context对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity的引用，如果在activity onDestroy时没有释放掉引用就会引起内存泄漏。
>> ##### 解决方法
>> 1. 使用ApplicationContext代替ActivityContext。
>> 2. 在Activity执行onDestroy时进行反注册.
>>
> #### 6.Cursor,Stream没有close,View没有recycle
>> 资源性对象比如(Cursor,File文件等)往往都用了一些缓冲，在我们不使用的时候，应该及时关闭他们，以便他们的缓冲及时回收。他们的缓存不止存在java虚拟机内还存在于java虚拟机外。如果我们仅仅把他们的引用设置为null，而不关闭他们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它会自己调close()关闭)，但是这样效率太低。因此对于资源性对象在不使用的时候，应该调用他的close()函数，将其关闭，然后再设置为null。在我们退出时一定要确定我们的资源性对象已经关闭。
>> ##### 解决方法
>> - 调用onRecycle()
> #### 7.集合中对象没清理造成的内存泄漏
>> 我们通常会把一些对象的引用加入到集合容器(如ArrayList)中，当我们不需要该对象的时候，并没有将集合内的引用清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更加严重了。
>> ##### 解决方法
>> - 在activity退出之前，将集合里的东西clear,然后置为null，再退出程序。
> #### 8.WebView造成的泄露
>> 当我们不适用WebView对象时，应该调用它的destroy函数来销毁它，并释放其内存，否则其内存长期占用的得不到释放，从而导致内存泄漏。
>> ##### 解决方法
>> - 为webview开启另外一个进程，通过AIDL与主线程通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。
> #### 9.构造Adapter时，没有使用缓存的ConvertView
>> 初始时ListView会从Adapter中根据当前的屏幕布局实例化一些数量的View对象，同时ListView会将这些View对象缓存起来。
>> 当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的ListItem。
>> 这个构造过程就是由getView()方法完成的，getView方法的第二个参数convertView就是被缓存起来的List Item的View对象(初始化缓存中没有View对象则convertView为null)。


## 4.Java 中的 ==, equals 与 hashCode 的区别与联系
> #### ==
> - 若数据类型是**基本数据类型**，则表示的是两边**操作数的值是否相等**
> - 若数据类型是**引用数据类型**，则表示的是两边**对象的内存地址是否相等**,若为true则是同一个对象。
> #### equals方法
> Object中的实例方法
>> 使用equals方法，内部实现分三步:
>> - 先比较引用是否相同(是否有同一对象)
>> - 在比较两个对象是否是同一类型
>> - 比较内容是否一致
> - 本意是比较**两个对象的content是否相同**
> #### hashCode 方法
> hashCode是基类Object中的实例native方法
> - 获取对象的哈希值，用于确定对象在哈希表中的索引位置，是一个int整数
> - hashcode是系统用来快速检索对象而使用


## 5.synchronized 和 volatile 、ReentrantLock 、CAS 的区别
> #### synchronized
> 被synchronized修饰的代码段可以防止被多个线程同时执行。线程的可见性，原子性，有序性都可以保证了。
> #### volatile
> 被volatile修饰的变量具有可见性和有序性。被volatile修饰的变量在修改后将强制刷新到内存中。另外在指令重排序优化时，在volatile之前的指令不能在volatile之后执行，在volatile之后的指令不能在volatile之前执行。
> #### volatile和synchronized的作用和区别是什么
> - volatile只能作用于变量。synchronized能作用于方法和代码块，使用范围较广。
> - volatile只能保证可见性和有序性，而synchronized还能保证原子性。
> - volatile不会造成线程阻塞，而synchronized则有可能。
> #### CAS机制
> CAS是英文单词Compare and Swap的缩写，翻译过来就是比较并替换。
> CAS机制使用了三个基本操作数，内存地址V，旧的期望值A，要修改的新值B。
> 要更新一个变量时候，只有当变量的预期值A和内存地址V的实际值相同时，才会将内存地址V对应的值修改为B。
>> ##### 缺点
>> 1. **CPU开销比较大**
>> 在并发量较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直不成功，循环往复，会给CPU造成很大的压力。
>> 2. **ABA问题**
>> 当一个值从A变成B,又变回A，普通CAS机制会误判通过检测。需要增加版本号来进行解决。
> #### ReenTrantLock(重入锁)和synchronized区别
> 1. 可重入性：
> ReenTrantLock和synchronized都是可重入的。两者都是同一个线程每进入一次，锁的计数器自增1，只有等锁计数器下降为0才能释放锁。
> 2. 锁的实现：
> synchronized是依赖JVM实现的，而ReenTrantLock是JDK实现的。
> 3. 性能的区别：
> 自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多。
> 4. 功能区别：
> synchronized使用比较方便。而ReenTrantLock需要手动声明来加锁和释放锁资源。
> 5. 锁的粒度：
> 很明显ReenTrantLock优于synchronized
>> 1. ReenTrantLock可以指定公平锁和非公平锁。而synchronized只能是非公平锁。公平锁就是先等待的线程先获得锁。
>> 2. ReenTrantLock提供了一个Condition类，可以用来实现分组唤醒需要唤醒的线程。
>> 3. ReenTrantLock提供了一种能中断等待锁的机制，通过lock.lockInterruptibly（）来实现该机制。
> ##### 什么情况下使用ReenTrantLock
> 如果需要实现ReenTrantLock三个独有功能时。


## 6. [Handler消息机制原理](https://blog.csdn.net/wsq_tomato/article/details/80301851)
> #### Handler适用于两个线程间的通信
> 1. 在使用handler的时候，在handler创建的线程需要维护一个唯一的对象，每个线程对应一个Looper，每个线程的Looper通过ThreadLocal存储，Looper内部中又有一个唯一的MessageQueue，所以一个线程可以有多个Handler，但是只能有一个Looper和一个MessageQueue。
> 2. Message在MessageQueue中不是通过一个列表来存储的，而是将传入的Message传入到上一个Message的next中，在取出的时候通过顶部的Message就能按放入的顺序依次取出Message。
> 3. Looper对象通过loop()方法开启了一个死循环，不断地从looper内的MessageQueue中取出Message,然后通过handler将消息分回发送给handler所在的线程处理。
> 
>> ##### 内存泄漏
>> 1. 非静态内部类持有外部类的引用，若线程没有销毁，则意味着Activity会一直被Handler持有而无法回收。
>> 2. 同时MessageQueue中如果存在未处理完的Message，Message的target也会对Activity持有引用，造成内存泄漏。
>> ##### 解决方法 
>> 1. 使用静态内部类+弱引用的方式。
>> 2. 在外部类被销毁对象时，将MessageQueue中的消息清空。例如在Activity的onDestroy中清空消息队列。
> #### 为什么不直接new一个Message，而是通过Message.obtain()
> 使用obtain是因为Message内部维护了一个数据的缓存池，回收的Message不会立刻被销毁，而是放入了缓存池中，只有在缓存池为空的时候才会创建一个Message。
> #### sendMessageDelayed是如何实现延迟发送消息的
> handler在发送消息时，messagequeue中的消息是按发送时间顺序由小到大排列的，如果最近的的Message未到达发送时间则阻塞。
> #### sendMessageDelayed是通过阻塞来达到了延时发送消息的结果，那么会不会阻塞新添加的Message
> 新加入的数据会根据时间大小判断插入的位置，同时还需要判断是否需要唤醒线程去发送当前队首的消息。



