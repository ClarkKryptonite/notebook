# Network Related
## 1. 三次握手四次挥手
> 置位概念：根据TCP的包头字段，存在3个重要的标识ACK、SYN、FIN
>> **ACK:** 表示验证字段
>> **SYN:** 位数置1，表示建立TCP连接 
>> **FIN:** 位数置1，表示断开TCP连接
> #### 三次握手
> 一开始客户端处于CLOSED状态，服务端处于LISTEN状态。
> 1. 客户端会发SYN报文，并指明客户端初始序列号seq=x，此时客户端处于SYN_SENT状态。**(SYN=1,seq=x)**
> 2. 服务器收到客户端的SYN报文后，会以自己的SYN报文作为应答，生成自己的初始序列号seq=y，同时会把客户端的seq值+1作为ack的值，表示自己收到了客户端得请求，此时服务端处于SYN_RCVD状态。**(SYN=1,ACK=1,seq=y,ack=x+1)**
> 3. 客户端收到SYN报文后，会发送一个ACK报文，一样是把服务端的序列号+1作为ack的值ack=y+1，同时序列号的值在原来的基础上加一即seq=x+1。发送报文后客户端处于ESTABLISHED状态，在服务端收到ACK报文后也处于ESTABLISHED状态。 **(ACK=1，seq=x+1,ack=y+1)**
>> ##### 为什么要三次握手，两次不行吗
>> - 只有三次握手才能确保双方都知道自己得接收和发送能力正常。
> #### 四次挥手
> 刚开始双方都处于ESTABLISHED状态。
> 1. 客户端会发FIN报文，报文指定一个序列号，此时客户端处于FIN_WAIT1状态。**(FIN=1,seq=u)**
> 2. 服务端收到报文后，会发送一个ACK报文，并把客户端的序列号+1作为ACK报文序列号的值，此时服务器处于CLOSE_WAIT状态。此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2状态。**(ACK=1,seq=v,ack=u+1)**
> 3. 如果服务器也想断开连接，和客户端第一次挥手一样，发给FIN报文，且指定一个序列号。此时服务端处于LAST_ACK状态，等待客户端确认。**(FIN=1,ACK=1,seq=w,ack=u+1)** 
> 4. 客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务器的序列号加一作为ACK报文序列号的值，此时客户端处于TIME_WAIT状态。需要过一阵子以确保服务器接收到自己的ACK报文才会进入CLOSED状态，服务端接收到ACK报文后，就处于关闭连接CLOSED状态。**(ACK=1,seq=u+1，ack=w+1)**
>> ##### 挥手为什么要四次
>> - 当服务端接收到客户端的SYN连接请求报文后，可以直接发送ACK+SYN报文。其中ACK是用来应答的，SYN是用来同步的。
>> - 但是关闭连接时，当服务端接收到FIN报文时，很可能不会关闭所有的socket。所以先回复一个ACK报文，告诉客户端你发的FIN报文我已经接收到了。只有等服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。
>> ##### 四次挥手释放连接时，等待2MSL的意义
>> - 保证客户端发送的最后一个ACK报文能到达服务端
>> - 防止“已失效连接请求报文段”出现在本连接中

## 2. 数字证书
> 1. Client发出协议版本号，一个随机数和支持的加密算法(如RSA密钥加密算法)给Server
> 2. Server确认协议版本号，对称加密算法，并生成一个随机数，再将Server的数字证书发给Client
> 3. Client验证Server的数字证书，并再次生成一个随机数pre-master secret,然后用数字证书中的公钥对该随机数加密发送给Server
> 4. Server用私钥解密该随机数。
> 5. Client和Server依据之前三个随机数以及约定好的加密算法生成对话密钥(session key)